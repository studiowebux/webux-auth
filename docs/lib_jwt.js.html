<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/jwt.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/jwt.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * File: jwt.js
 * Author: Tommy Gingras
 * Date: 2019-08-18
 * License: All rights reserved Studio Webux S.E.N.C 2015-Present
 */

"use strict";

const jwt = require("jsonwebtoken");
let redis;
let client;

/**
 * Initialize the Redis connection
 * @param {object} options
 */
const initializeRedis = options => {
  if (options.mock === true) {
    console.log("\x1b[33m", "Webux-auth - Starting redis mock", "\x1b[0m");
    redis = require("redis-mock");
    client = redis.createClient();

    client.on("error", function(err) {
      console.error("\x1b[31m", "Webux-auth - Redis error", "\x1b[0m");
      console.error("\x1b[31m", err, "\x1b[0m");
    });
  } else {
    console.log("\x1b[33m", "Webux-auth - Starting redis client", "\x1b[0m");
    redis = require("redis");
    client = redis.createClient({
      host: options.host,
      no_ready_check: options.no_ready_check,
      password: options.password,
      port: options.port
    });
    client.on("error", function(err) {
      console.error("\x1b[31m", "Webux-auth - Redis error", "\x1b[0m");
      console.error("\x1b[31m", err, "\x1b[0m");
    });
  }
};

/**
 * This function save the token information in a redis database
 * This will allow to manage the token and blacklist the tokens.
 * @param {String} type Must be access or refresh
 * @param {String} token The JWT token
 * @param {String} userID
 * @param {String} expiresIn Time in seconds for the token to expire
 * @param {String} ip The IP of the user
 * @param {Objct} log
 * @returns {Promise}
 */
function saveToken(type, token, userID, expiresIn, ip, log = console) {
  return new Promise((resolve, reject) => {
    try {
      client.hmset(
        token, // The Unique ID
        "type",
        type, // 'access' or 'refresh' token
        "userID",
        userID, // the userID associated with the token
        "from",
        ip || "Unknown", // The IP of the user
        "createdAt",
        new Date(), // The creation date of that entry
        (err, response) => {
          if (err || !response) {
            log.error(err || "Unable to save the token in Redis");
            return reject(err);
          }
          client.expire(token, expiresIn);
          return resolve(response);
        }
      );
    } catch (e) {
      log.error(e);
      throw e;
    }
  });
}

/**
 * This function will return the user object with specific key-value
 * @param {Object} user The user object retrieved from the backend/database
 * @param {Object} fields It must be an array containing the keys allowed in the JWT payload
 * @param {Object} log
 * @returns {Object} the user ready to be serialize
 */
function serializeUser(user, fields, log = console) {
  const payload = {};
  Object.keys(user).forEach(field => {
    if (fields.includes(field)) {
      payload[field] = user[field];
    }
  });
  return payload;
}

/**
 * This function will generate a JWT token based on the type supplied.
 * @param {Object} options
 * @param {Object} user
 * @param {String} type must be access or refresh
 * @param {String} ip
 * @param {Object} log
 * @returns {Promise} containing the generated token
 */
const GenerateToken = (options, user, type, ip = null, log = console) => {
  return new Promise(async (resolve, reject) => {
    try {
      // Generate the payload using the options.serializeUser array
      const payload = serializeUser(user, options.serializeUser);
      // Sign the token using the secret and the payload
      const token = jwt.sign(payload, options[type + "Secret"], {
        expiresIn: options[type + "Life"]
      });

      // Save the token in redis
      const saved = await saveToken(
        type,
        token,
        user[options.id],
        options[type + "Life"],
        ip
      ).catch(e => {
        log.error(e);
        return reject(e);
      });

      if (!saved) {
        log.error(type + " token not saved in Redis.");
        return reject(new Error(type + " token not saved in Redis."));
      }

      return resolve(token);
    } catch (e) {
      log.error(e);
      throw e;
    }
  });
};

/**
 * Check if the access token match the supplied user ID.
 * @param {String} accessToken
 * @param {String} userID
 * @param {Object} log
 * @returns {Promise} Return true if everything is fine
 */
const CheckToken = (accessToken, userID, log = console) => {
  return new Promise((resolve, reject) => {
    try {
      client.hgetall(accessToken, (err, obj) => {
        if (err || !obj) {
          log.error(err || "Token not found in Redis");
          return reject(err || new Error("Token not found"));
        } else if (obj.userID == userID) {
          return resolve(true);
        } else {
          log.error("Something went wrong, no error nor object");
          return reject(new Error("The information does not match."));
        }
      });
    } catch (e) {
      log.error(e);
      throw e;
    }
  });
};

/**
 * This funtion use a refresh token to renew and generated a new access token.
 * steps, the refreshToken must be valid and not blacklisted
 * @param {Object} options
 * @param {String} refreshToken
 * @param {String} userID
 * @param {String} ip
 * @param {Object} log
 * @returns {Promise} containing the access token.
 */
const RefreshAccessToken = (
  options,
  refreshToken,
  userID,
  ip = null,
  log = console
) => {
  return new Promise((resolve, reject) => {
    try {
      jwt.verify(refreshToken, options.refreshSecret, (err, decoded) => {
        if (err) {
          log.error(err);
          throw err;
        } else {
          client.hgetall(refreshToken, async (err, obj) => {
            if (err || !obj) {
              log.error(err || "Refresh token not found in Redis");
              return reject(err || new Error("Token not Found"));
            } else if (obj.userID == userID &amp;&amp; obj.type === "refresh") {
              const token = await GenerateToken(
                options,
                decoded,
                "access",
                ip
              ).catch(e => {
                log.error(e);
                throw e;
              });
              if (!token) {
                log.error("No access token generated");
                return reject(new Error("No access token generated"));
              } else {
                return resolve(token);
              }
            } else {
              log.error("Something went wrong, no error nor object");
              return reject(new Error("The information does not match"));
            }
          });
        }
      });
    } catch (e) {
      log.errror(e);
      throw e;
    }
  });
};

/**
 * Using the refresh token, it will remove it from redis and blacklisting it in the same occasion.
 * @param {String} token
 * @param {String} userID
 * @param {Object} log
 * @returns {Promise} return true or false
 */
const RevokeToken = (token, userID = null, log = console) => {
  return new Promise((resolve, reject) => {
    try {
      client.del(token, err => {
        if (!err) {
          if (userID) {
            client.hdel(userID, token, err => {
              if (!err) {
                return resolve(true);
              } else {
                log.error(
                  err ||
                    "Something went wrong while deleting the userID + token from Redis"
                );
                return reject(err);
              }
            });
          } else {
            return resolve(true);
          }
        } else {
          log.error(
            err || "Something went wrong while deleting the token from Redis"
          );
          return reject(err);
        }
      });
    } catch (e) {
      log.error(e);
      throw e;
    }
  });
};

/**
 * Return the access and refresh token in an object.
 * @param {Object} options
 * @param {Object} user
 * @param {String} ip
 * @param {Object} log
 * @returns {Object} {access:"", refresh:""}
 */
const GenerateJWT = async (options, user, ip = null, log = console) => {
  try {
    const token = {};
    token.access = await GenerateToken(options, user, "access", ip).catch(e => {
      log.error(e);
      throw e;
    });
    token.refresh = await GenerateToken(options, user, "refresh", ip).catch(
      e => {
        log.error(e);
        throw e;
      }
    );

    return token;
  } catch (e) {
    log.error(e);
    throw e;
  }
};

module.exports = {
  GenerateJWT,
  RevokeToken,
  RefreshAccessToken,
  CheckToken,
  initializeRedis
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#activateAccount">activateAccount</a></li><li><a href="global.html#activationCode">activationCode</a></li><li><a href="global.html#checkPassword">checkPassword</a></li><li><a href="global.html#CheckToken">CheckToken</a></li><li><a href="global.html#errorHandler">errorHandler</a></li><li><a href="global.html#GenerateCode">GenerateCode</a></li><li><a href="global.html#GenerateJWT">GenerateJWT</a></li><li><a href="global.html#GenerateToken">GenerateToken</a></li><li><a href="global.html#initializeRedis">initializeRedis</a></li><li><a href="global.html#initJWTStrategy">initJWTStrategy</a></li><li><a href="global.html#initLocalStrategy">initLocalStrategy</a></li><li><a href="global.html#isAuthenticated">isAuthenticated</a></li><li><a href="global.html#lostPassword">lostPassword</a></li><li><a href="global.html#RefreshAccessToken">RefreshAccessToken</a></li><li><a href="global.html#retrievePassword">retrievePassword</a></li><li><a href="global.html#RevokeToken">RevokeToken</a></li><li><a href="global.html#saveToken">saveToken</a></li><li><a href="global.html#serializeUser">serializeUser</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Sep 01 2019 08:53:37 GMT-0400 (GMT-04:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
